import subprocess
import base64
import re
import time
import string
from Crypto.Cipher import AES

"""
Block size is 16.
We inputb64enc a chars. One more every time untile we see an additional block being added to the hex output.
We now know that the last block is an entire block size of padding bytes.
We increase the number of input bytes by one. We now know, that the last block contains one flag byte followed
by 15 padding bytes. We save the last block for comparison later.
We now loop through all possible characters plus 15 byte padding encoded as b64 and input
the result. If we used the correct input character, the first hex block of the result will match the saved block.
"""

p = subprocess.Popen(["/challenge/run"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
pat0 = re.compile(r".*ciphertext \(hex\): ([0-9a-f]*) [0-9a-f]* [0-9a-f]* [0-9a-f]* ([0-9a-f]*).*")

def calc_flag_len_and_init_input(p, pat0):
	init_input = b""
	while True:
		line = p.stdout.readline()
		line = line.decode("utf-8")
		print(line, end='')
		m = pat0.match(line)
		if m:
			current_last_hex_block = m.group(2)
			if current_last_hex_block:
				flag_len = 4*16 - len(init_input)
				print(f"Flag len set to 4*16-{len(init_input)}={flag_len}")
				break
			init_input = init_input + b"a"
			print(f"Calc flag len input: {init_input} {base64.standard_b64encode(init_input)}")
			p.stdin.write(base64.standard_b64encode(init_input) + b"\n")
			p.stdin.flush()
	return flag_len, init_input


flag_len, init_input = calc_flag_len_and_init_input(p, pat0)

alphabet = list(string.ascii_letters) + list(string.punctuation) + list(string.whitespace) + list(string.digits)
alphabet = list(map(lambda x:x.encode("utf-8"), alphabet))
alphabet_index = 0
check_alphabet = False
check_alphabet_input = b""
input_padding_len = 16
saved_hex_block = None
result = ""

print(f"Init input {init_input} {base64.standard_b64encode(init_input)}")
p.stdin.write(base64.standard_b64encode(init_input) + b"\n")
p.stdin.flush()
while True:
	line = p.stdout.readline()
	line = line.decode("utf-8")
	print(line, end='')
	m = pat0.match(line)
	if m:
		current_first_hex_block = m.group(1)
		current_last_hex_block = m.group(2)
		print(f"Current first {current_first_hex_block}")
		print(f"Current last {current_last_hex_block}")
		print(f"Result: {result[::-1]}")
		if not check_alphabet and (flag_len is not 0):
			flag_len = flag_len - 1
			input_padding_len = input_padding_len - 1
			init_input = init_input + b"a"
			check_alphabet = True
			print(f"Find flag char {flag_len} {init_input} {base64.standard_b64encode(init_input)}")
			p.stdin.write(base64.standard_b64encode(init_input) + b"\n")
			p.stdin.flush()
		else:
			if not saved_hex_block:
				saved_hex_block = current_last_hex_block
				print(f"Saved hex block {saved_hex_block}")
				p.stdin.write(base64.standard_b64encode(init_input) + b"\n")
				p.stdin.flush()
			else:
				if saved_hex_block == current_first_hex_block:
					saved_hex_block = None
					alphabet_index = 0
					check_alphabet = False
					result = result + check_alphabet_input.decode("utf-8")[0]
					print(f"Current result {result}")
					p.stdin.write(base64.standard_b64encode(check_alphabet_input) + b"\n")
					p.stdin.flush()
				else:
					if (input_padding_len > 0) and (alphabet_index < len(alphabet)):
						pad = chr(input_padding_len).encode("utf-8")*input_padding_len
						check_alphabet_input = alphabet[alphabet_index] + result[::-1].encode("utf-8") + pad
						print(f"Input {check_alphabet_input} {base64.standard_b64encode(check_alphabet_input)}")
						alphabet_index = alphabet_index + 1
						p.stdin.write(base64.standard_b64encode(check_alphabet_input) + b"\n")
						p.stdin.flush()
					elif (input_padding_len <= 0) and (alphabet_index < len(alphabet)):
						res = result[::-1]
						check_alphabet_input = alphabet[alphabet_index] + res[:15].encode("utf-8")
						print(f"Input {check_alphabet_input} {base64.standard_b64encode(check_alphabet_input)}")
						alphabet_index = alphabet_index + 1
						p.stdin.write(base64.standard_b64encode(check_alphabet_input) + b"\n")
						p.stdin.flush()
					else:
						break

