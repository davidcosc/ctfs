import base64
import os
import re
import string


"""
Theory:
	AES in ECB mode uses the same key to encrypt multiple parts of a message.
	It splits the message into same sized blocks with the last block containing
	as much padding as necessary up to an entire block of padding. The padding
	consists of single bytes with each byte value containing the padding length.
	In a 16 bit block size a block of a single message char a followed by 15 bytes
	of padding would look like this: a0F0F0F0F...0F

	If we have access to a system that lets us encrypt partially unknown messages,
	we can attempt to decrypt the unknown message parts by trying to manipulate the
	message in a way such that we isolate a single byte of the unknown message
	in the padding block. We know exactly what the padding looks like and can then
	encrypt multiple messages changing the isolated byte to a different char every
	time until we find the char that results in a block that matches the targeted
	block (collision). We can repeat this process by using the already decrypted
	bytes as well as potentially remaining padding to isolate and decrypt another
	byte.

    key = get_random_bytes(16)
    cipher = AES.new(key=key, mode=AES.MODE_ECB)

    ciphertext = cipher.encrypt(pad(flag, cipher.block_size))
    show_b64("secret ciphertext", ciphertext)
    show_hex_block("secret ciphertext", ciphertext)

    while True:
        plaintext_prefix = input_b64("plaintext prefix")
        ciphertext = cipher.encrypt(pad(plaintext_prefix + flag, cipher.block_size))
        show_b64("ciphertext", ciphertext)
        show_hex_block("ciphertext", ciphertext)
"""
prefix = ""
blockc = 0
block_size = 16  # key length
flag_len = 0
alphabet = list(string.ascii_letters) + list(string.digits) + list(string.punctuation) + ["\n"]
alpha_idx = 0
alpha_input = None
padding_len = 15
compare_block = None
result = ""
pat0 = re.compile(r".*ciphertext \(hex\): (.*)\n")
r_pipe0, w_pipe0 = os.pipe()
r_pipe1, w_pipe1 = os.pipe()
pid = os.fork()

if pid == -1:
	print("Error fork.")

if pid == 0:
	os.close(w_pipe0)
	os.close(r_pipe1)

	os.dup2(r_pipe0, 0)
	os.close(r_pipe0)

	os.dup2(w_pipe1, 1)
	os.close(w_pipe1)

	os.execv("/challenge/run", ["/challenge/run"])
	print("Error execv.")
	exit(1)

os.close(r_pipe0)
os.close(w_pipe1)

output = os.fdopen(r_pipe1, "r")
input = os.fdopen(w_pipe0, "wb")

# find out prefix len that results in a full block of padding added to cipher and calc flag len
while True:
	line = output.readline()
	print(line, end="")
	m = pat0.match(line)
	if m:
		blockc = len(m.group(1).strip().split(" "))
		if blockc == 5:
			flag_len = block_size * 4 - len(prefix)
			print(f"Prefix {prefix} resulted in full padding block 5")
			print(f"Calculated flag length {flag_len}")
			break
		prefix = prefix + "a"
		input.write(base64.standard_b64encode(prefix.encode("utf-8")) + b"\n")
		input.flush()

# write prifix that results in a 5th cipher block of a single encrypted flag char and 15 bytes of padding
prefix = prefix + "a"
input.write(base64.standard_b64encode(prefix.encode("utf-8")) + b"\n")
input.flush()

# find out flag char by char
while True:
	line = output.readline()
	print(line, end="")
	m = pat0.match(line)
	if m:
		first_block = m.group(1).strip().split(" ")[0]
		if not compare_block:
			compare_block = m.group(1).strip().split(" ")[4]
			print(f"Set compare block to {compare_block}")
		if first_block == compare_block:
			result = result + alpha_input.decode("utf-8")[0]
			print(f"Got first block {first_block} comp block {compare_block} result {result}")
			compare_block = None
			alpha_idx = 0
			padding_len -= 1
			prefix = prefix + "a"
			input.write(base64.standard_b64encode(prefix.encode("utf-8")) + b"\n")
			input.flush()
		if compare_block and padding_len > 0:
			padding = chr(padding_len).encode("utf-8")*padding_len
			alpha_input = alphabet[alpha_idx].encode("utf-8") + result[::-1].encode("utf-8") + padding
#			print(f"Testing pad len {padding_len} {alpha_input}")
			input.write(base64.standard_b64encode(alpha_input) + b"\n")
			input.flush()
			alpha_idx += 1
		if compare_block and padding_len <= 0:
			if len(result) == flag_len:
				print(f"Flag {result[::-1]}")
				break
			rev_res = result[::-1]
			alpha_input = alphabet[alpha_idx].encode("utf-8") + rev_res[:15].encode("utf-8")
#			print(f"Testing pad len {padding_len} {alpha_input}")
			input.write(base64.standard_b64encode(alpha_input) + b"\n")
			input.flush()
			alpha_idx += 1
