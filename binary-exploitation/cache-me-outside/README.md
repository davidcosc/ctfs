
# Cache Me Outside picoCTF 2021

## Solve locally and remote
- `chmod +x ./heapedit`
- `../../pwninit`
- `./cmo.py`
- `./cmo.py REMOTE`

## Explanation
As the hint suggests, this problem is focused on the tcache. The tcache is a glibc feature to speed up memory allocation in user space. It is used to cache previously freed memory chunks.
Subsequent malloc calls that request a size of memory, that matches a tcached chunk will allocate that chunk and remove it from the cache. Mallocs of this type do not have to go to the lengthy
process of requesting memory from the kernel via mmap.

Each thread has its own tcache. One of the reasons it was designed this way, is to prevent handling race conditions between threads.
In order to tackle thee cache mme outside problem, we have to understand two important tcache structures.

```
source: https://elixir.bootlin.com/glibc/latest/source/malloc/malloc.c#L3125

# define TCACHE_MAX_BINS 64
# define TCACHE_FILL_COUNT 7

/* We overlay this structure on the user-data portion of a chunk when
   the chunk is stored in the per-thread cache.  */
typedef struct tcache_entry
{
  struct tcache_entry *next;
  /* This field exists to detect double frees.  */
  uintptr_t key;
} tcache_entry;

/* There is one of these for each thread, which contains the
   per-thread cache (hence "tcache_perthread_struct").  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  */
typedef struct tcache_perthread_struct
{
  uint16_t counts[TCACHE_MAX_BINS];
  tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```

By default, each thread has 64 singly-linked tcache bins. Each bin contains a maximum of 7 same-size chunks ranging from 24 to 1032 bytes on 64-bit systems and 12 to 516 bytes on 32-bit systems.
